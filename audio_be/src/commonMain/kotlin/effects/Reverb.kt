package io.peekandpoke.klang.audio_be.effects

import io.peekandpoke.klang.audio_be.StereoBuffer

/**
 * A high-performance Stereo Reverb based on the Freeverb algorithm (Schroeder/Moorer architecture).
 *
 * **How it works:**
 * Simulates the complex reflections of an acoustic space using a network of delay-based filters.
 * The signal flows through 8 parallel Comb Filters (creating resonance/echo density) and then
 * through 4 series All-Pass Filters (diffusing the sound/smearing transients).
 *
 * **Implementation Details & Performance:**
 * - **Structure of Arrays (SoA):** Unlike a typical OOP implementation using `Comb` and `AllPass` objects,
 *   this implementation flattens all filter states into primitive arrays (`combBufsL`, `combPosL`, etc.).
 *   - *Why?* This eliminates object overhead and removes virtual method calls inside the audio loop
 *     (saving ~2 million method calls per second at 48kHz). It also significantly improves CPU cache locality.
 * - **Inlined Processing:** The DSP logic is inlined directly into the main loop to allow the JIT compiler
 *   to vectorize operations where possible.
 *
 * **Musical Design:**
 * - **Stereo Decorrelation:** The Right channel uses the same tuning as the Left channel but with an
 *   added "Stereo Spread" (+23 samples) to all delay lines. This ensures a wide stereo image even with mono inputs.
 * - **Gain Staging:** A fixed scaling factor (`fixedGain = 0.015`) is applied to normalize the massive signal
 *   generated by summing 8 resonant comb filters, preventing internal clipping.
 *
 * **Strudel Parameter Mapping:**
 * - `room`: Controls the Wet/Dry mix.
 * - `size`: Controls the Feedback amount (decay tail length).
 * - `roomLp`: Controls the damping coefficient of the comb filters (simulation of air absorption).
 */
class Reverb(
    val sampleRate: Int,
) {
    // --- Tuning (Freeverb Standard) ---
    private val combTuning = intArrayOf(1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617)
    private val allPassTuning = intArrayOf(556, 441, 341, 225)
    private val stereoSpread = 23

    // --- State (Flattened for Performance) ---
    // We store buffers in arrays of arrays to avoid object overhead per filter
    private val numCombs = combTuning.size
    private val numAllPass = allPassTuning.size

    // Left Channel State
    private val combBufsL = Array(numCombs) { DoubleArray(combTuning[it]) }
    private val combPosL = IntArray(numCombs)
    private val combStoreL = DoubleArray(numCombs) // Low-pass filter history

    private val apBufsL = Array(numAllPass) { DoubleArray(allPassTuning[it]) }
    private val apPosL = IntArray(numAllPass)

    // Right Channel State (Decorrelated)
    private val combBufsR = Array(numCombs) { DoubleArray(combTuning[it] + stereoSpread) }
    private val combPosR = IntArray(numCombs)
    private val combStoreR = DoubleArray(numCombs)

    private val apBufsR = Array(numAllPass) { DoubleArray(allPassTuning[it] + stereoSpread) }
    private val apPosR = IntArray(numAllPass)

    // --- Parameters ---

    /** Master mix volume. */
    var mix: Double = 0.0

    var roomSize: Double = 0.5
    var damp: Double = 0.5

    // Strudel Extended Parameters
    var roomFade: Double? = null
    var roomLp: Double? = null
    var roomDim: Double? = null // Unused in standard Freeverb, but kept for interface compat
    var iResponse: String? = null

    // Constants
    private val fixedGain = 0.015 // Standard Freeverb gain scaling to normalize sum of 8 combs
    private val allPassFeedback = 0.5

    fun process(input: StereoBuffer, output: StereoBuffer, length: Int) {
        val inL = input.left
        val inR = input.right
        val outL = output.left
        val outR = output.right

        // --- 1. Control Rate Calculations (Once per block) ---

        // Feedback (Room Size)
        val effectiveSize = roomFade ?: roomSize
        val feedback = (effectiveSize * 0.28) + 0.7

        // Damping (Low Pass)
        val effectiveDamp = if (roomLp != null) {
            val nyquist = sampleRate / 2.0
            (roomLp!! / nyquist).coerceIn(0.0, 1.0).let { 1.0 - it }
        } else {
            damp
        }
        val damping = effectiveDamp * 0.4

        // Pre-calculate inverse damping for speed
        val invDamping = 1.0 - damping

        // Final output gain
        val outputGain = mix * fixedGain

        // --- 2. Audio Rate Processing ---

        for (i in 0 until length) {
            val inpL = inL[i]
            val inpR = inR[i]

            var sumL = 0.0
            var sumR = 0.0

            // --- Parallel Comb Filters ---
            // Inlined logic removes 16 method calls per sample
            for (c in 0 until numCombs) {
                // Left
                val bufL = combBufsL[c]
                val sizeL = bufL.size
                var posL = combPosL[c]

                val outSampleL = bufL[posL]
                combStoreL[c] = (outSampleL * invDamping) + (combStoreL[c] * damping)
                bufL[posL] = inpL + (combStoreL[c] * feedback)

                sumL += outSampleL

                if (++posL >= sizeL) posL = 0
                combPosL[c] = posL

                // Right
                val bufR = combBufsR[c]
                val sizeR = bufR.size
                var posR = combPosR[c]

                val outSampleR = bufR[posR]
                combStoreR[c] = (outSampleR * invDamping) + (combStoreR[c] * damping)
                bufR[posR] = inpR + (combStoreR[c] * feedback)

                sumR += outSampleR

                if (++posR >= sizeR) posR = 0
                combPosR[c] = posR
            }

            // --- Series All-Pass Filters ---
            // Inlined logic removes 8 method calls per sample
            for (a in 0 until numAllPass) {
                // Left
                val bufL = apBufsL[a]
                val sizeL = bufL.size
                var posL = apPosL[a]

                val bufOutL = bufL[posL]
                val newOutL = -sumL + bufOutL
                bufL[posL] = sumL + (bufOutL * allPassFeedback)
                sumL = newOutL

                if (++posL >= sizeL) posL = 0
                apPosL[a] = posL

                // Right
                val bufR = apBufsR[a]
                val sizeR = bufR.size
                var posR = apPosR[a]

                val bufOutR = bufR[posR]
                val newOutR = -sumR + bufOutR
                bufR[posR] = sumR + (bufOutR * allPassFeedback)
                sumR = newOutR

                if (++posR >= sizeR) posR = 0
                apPosR[a] = posR
            }

            // --- Mix to Output ---
            outL[i] += sumL * outputGain
            outR[i] += sumR * outputGain
        }
    }
}
