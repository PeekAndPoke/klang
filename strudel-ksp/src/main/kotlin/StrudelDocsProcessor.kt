package io.peekandpoke.klang.strudel.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.google.devtools.ksp.validate

/**
 * KSP processor that generates documentation entries from @StrudelDsl annotated functions and properties.
 *
 * This processor:
 * 1. Finds all functions and properties annotated with @StrudelDsl
 * 2. Extracts KDoc documentation from those symbols
 * 3. Generates FunctionDoc entries automatically
 */
class StrudelDocsProcessor(
    environment: SymbolProcessorEnvironment,
) : SymbolProcessor {

    private val codeGenerator: CodeGenerator = environment.codeGenerator
    private val logger: KSPLogger = environment.logger

    override fun process(resolver: Resolver): List<KSAnnotated> {
        logger.info("StrudelDocsProcessor: Starting documentation generation")

        val annotated = resolver.getSymbolsWithAnnotation("io.peekandpoke.klang.strudel.lang.StrudelDsl")

        val strudelDslFunctions = annotated.filterIsInstance<KSFunctionDeclaration>().toList()
        val strudelDslProperties = annotated.filterIsInstance<KSPropertyDeclaration>().toList()

        logger.info("StrudelDocsProcessor: Found ${strudelDslFunctions.size} @StrudelDsl functions")
        logger.info("StrudelDocsProcessor: Found ${strudelDslProperties.size} @StrudelDsl properties")

        if (strudelDslFunctions.isEmpty() && strudelDslProperties.isEmpty()) {
            return emptyList()
        }

        generateDocsFile(strudelDslFunctions, strudelDslProperties)

        val unprocessed = mutableListOf<KSAnnotated>()
        unprocessed.addAll(strudelDslFunctions.filterNot { it.validate() })
        unprocessed.addAll(strudelDslProperties.filterNot { it.validate() })
        return unprocessed
    }

    private fun generateDocsFile(
        functions: List<KSFunctionDeclaration>,
        properties: List<KSPropertyDeclaration>,
    ) {
        // Collect all source files that contain @StrudelDsl symbols so KSP's incremental
        // cache knows to regenerate this file whenever any of them changes.
        val sourceFiles = (functions.mapNotNull { it.containingFile } +
                properties.mapNotNull { it.containingFile }).distinct()

        val file = codeGenerator.createNewFile(
            dependencies = Dependencies(aggregating = true, *sourceFiles.toTypedArray()),
            packageName = "io.peekandpoke.klang.strudel.lang.docs",
            fileName = "GeneratedStrudelDocs",
            extensionName = "kt"
        )

        file.bufferedWriter().use { writer ->
            writer.write(generateDocsCode(functions, properties))
        }

        logger.info("StrudelDocsProcessor: Generated documentation file")
    }

    private fun generateDocsCode(
        functions: List<KSFunctionDeclaration>,
        properties: List<KSPropertyDeclaration>,
    ): String {
        // Group by name to handle overloads and property+function pairs
        val functionsByName = functions.groupBy { it.simpleName.asString() }
        val propertiesByName = properties.groupBy { it.simpleName.asString() }
        val allNames = (functionsByName.keys + propertiesByName.keys).distinct().sorted()

        // Split into chunks to avoid JVM MethodTooLargeException (64 KB limit per method).
        // Each chunk becomes a separate private function so no single <clinit> or function
        // exceeds the JVM bytecode size limit.
        val chunks = allNames.chunked(8)

        return buildString {
            appendLine("// Generated by StrudelDocsProcessor - DO NOT EDIT")
            appendLine()
            appendLine("package io.peekandpoke.klang.strudel.lang.docs")
            appendLine()
            appendLine("import io.peekandpoke.klang.script.docs.*")
            appendLine()
            appendLine("/**")
            appendLine(" * Auto-generated Strudel DSL function documentation.")
            appendLine(" * Generated from @StrudelDsl annotated functions and properties.")
            appendLine(" * Platform-specific actual implementation of the expected declaration.")
            appendLine(" */")

            // One private function per chunk — each stays well within the 64 KB method limit.
            chunks.forEachIndexed { chunkIdx, chunk ->
                appendLine("private fun generatedDocsChunk$chunkIdx() = mapOf(")
                chunk.forEachIndexed { entryIdx, name ->
                    val overloads = functionsByName[name] ?: emptyList()
                    val props = propertiesByName[name] ?: emptyList()
                    append(generateDocEntry(name, overloads, props))
                    if (entryIdx < chunk.size - 1) {
                        appendLine(",")
                    }
                }
                appendLine()
                appendLine(")")
                appendLine()
            }

            // The actual val just combines all chunk maps — keeps <clinit> tiny.
            appendLine("actual val generatedStrudelFunctionDocs: Map<String, FunctionDoc> = buildMap {")
            chunks.forEachIndexed { chunkIdx, _ ->
                appendLine("    putAll(generatedDocsChunk$chunkIdx())")
            }
            appendLine("}")
        }
    }

    private fun generateDocEntry(
        functionName: String,
        overloads: List<KSFunctionDeclaration>,
        properties: List<KSPropertyDeclaration>,
    ): String {
        logger.info(
            "StrudelDocsProcessor: Processing '$functionName' — " +
                    "${overloads.size} function(s), ${properties.size} property(-ies)"
        )

        val parsedFunctionKDocs = overloads.map { function ->
            val kdoc = function.docString
            if (kdoc != null) {
                logger.info("StrudelDocsProcessor: KDoc found for function '$functionName'")
            } else {
                logger.warn("StrudelDocsProcessor: No KDoc found for function '$functionName'")
            }
            KDocParser.parse(kdoc)
        }

        val parsedPropertyKDocs = properties.map { property ->
            val kdoc = property.docString
            if (kdoc == null) {
                logger.warn("StrudelDocsProcessor: No KDoc found for property '$functionName'")
            }
            KDocParser.parse(kdoc)
        }

        val allParsedKDocs = parsedFunctionKDocs + parsedPropertyKDocs

        // Merge category, tags and aliases from all overloads and properties (prefer non-empty)
        val category = allParsedKDocs.mapNotNull { it.category }.firstOrNull() ?: "uncategorized"
        val allTags = allParsedKDocs.flatMap { it.tags }.distinct()
        val allAliases = allParsedKDocs.flatMap { it.aliases }.distinct()

        val tagsString = if (allTags.isNotEmpty()) {
            allTags.joinToString(", ") { "\"$it\"" }
        } else {
            ""
        }

        val aliasesString = if (allAliases.isNotEmpty()) {
            allAliases.joinToString(", ") { "\"$it\"" }
        } else {
            ""
        }

        // Functions first, then properties (properties are the raw/unscaled form)
        val variants = buildList {
            overloads.zip(parsedFunctionKDocs).forEach { (fn, kdoc) ->
                add(generateVariantDoc(fn, kdoc))
            }
            properties.zip(parsedPropertyKDocs).forEach { (prop, kdoc) ->
                add(generatePropertyVariantDoc(prop, kdoc))
            }
        }

        return buildString {
            appendLine()
            appendLine("    \"$functionName\" to FunctionDoc(")
            appendLine("        name = \"$functionName\",")
            appendLine("        category = \"$category\",")
            appendLine("        tags = listOf($tagsString),")
            appendLine("        aliases = listOf($aliasesString),")
            appendLine("        library = \"strudel\",")
            appendLine("        variants = listOf(")
            variants.forEachIndexed { index, variant ->
                append(variant)
                if (index < variants.size - 1) {
                    appendLine(",")
                }
            }
            appendLine()
            appendLine("        )")
            append("    )")
        }
    }

    private fun generateVariantDoc(function: KSFunctionDeclaration, kdoc: ParsedKDoc): String {
        // Determine variant type (TOP_LEVEL or EXTENSION_METHOD)
        val isExtension = function.extensionReceiver != null
        val variantType = if (isExtension) "DslType.EXTENSION_METHOD" else "DslType.TOP_LEVEL"

        // Build signature
        val signature = buildSignature(function)

        // Don't escape quotes in triple-quoted strings
        val description = kdoc.description.replace("\n", " ")

        // Generate parameter docs
        val paramDocs = function.parameters.mapNotNull { param ->
            val paramName = param.name?.asString() ?: return@mapNotNull null
            val paramType = param.type.resolve().toString()
            val paramDesc = kdoc.params[paramName] ?: ""

            val cleanDesc = paramDesc.replace("\n", " ")

            """
                ParamDoc(
                    name = "$paramName",
                    type = "$paramType",
                    description = "$cleanDesc"
                )
            """.trimIndent().prependIndent("                ")
        }

        val paramDocsString = if (paramDocs.isNotEmpty()) {
            paramDocs.joinToString(",\n")
        } else {
            ""
        }

        // Don't escape quotes in triple-quoted strings
        val returnDoc = kdoc.returnDoc.replace("\n", " ")

        // Generate sample strings - no escaping needed
        val samplesString = if (kdoc.samples.isNotEmpty()) {
            kdoc.samples.joinToString(",\n") { sample ->
                "                \"\"\"$sample\"\"\""
            }
        } else {
            ""
        }

        return buildString {
            appendLine("            VariantDoc(")
            appendLine("                type = $variantType,")
            appendLine("                signature = \"\"\"$signature\"\"\",")
            appendLine("                description = \"\"\"$description\"\"\",")
            if (paramDocs.isNotEmpty()) {
                appendLine("                params = listOf(")
                append(paramDocsString)
                appendLine()
                appendLine("                ),")
            } else {
                appendLine("                params = emptyList(),")
            }
            appendLine("                returnDoc = \"\"\"$returnDoc\"\"\",")
            if (kdoc.samples.isNotEmpty()) {
                appendLine("                samples = listOf(")
                append(samplesString)
                appendLine()
                appendLine("                )")
            } else {
                appendLine("                samples = emptyList()")
            }
            append("            )")
        }
    }

    private fun generatePropertyVariantDoc(property: KSPropertyDeclaration, kdoc: ParsedKDoc): String {
        val propertyName = property.simpleName.asString()
        val propertyType = cleanTypeName(property.type.resolve().toString())
        val isExtension = property.extensionReceiver != null
        val variantType = if (isExtension) "DslType.EXTENSION_METHOD" else "DslType.OBJECT"

        val signature = if (isExtension) {
            val receiverType = cleanTypeName(property.extensionReceiver!!.resolve().toString())
            "$receiverType.$propertyName: $propertyType"
        } else {
            "$propertyName: $propertyType"
        }

        val description = kdoc.description.replace("\n", " ")

        val samplesString = if (kdoc.samples.isNotEmpty()) {
            kdoc.samples.joinToString(",\n") { sample ->
                "                \"\"\"$sample\"\"\""
            }
        } else {
            ""
        }

        return buildString {
            appendLine("            VariantDoc(")
            appendLine("                type = $variantType,")
            appendLine("                signature = \"\"\"$signature\"\"\",")
            appendLine("                description = \"\"\"$description\"\"\",")
            appendLine("                params = emptyList(),")
            appendLine("                returnDoc = \"\",")
            if (kdoc.samples.isNotEmpty()) {
                appendLine("                samples = listOf(")
                append(samplesString)
                appendLine()
                appendLine("                )")
            } else {
                appendLine("                samples = emptyList()")
            }
            append("            )")
        }
    }

    private fun buildSignature(function: KSFunctionDeclaration): String {
        val functionName = function.simpleName.asString()

        // Get receiver type if it's an extension
        val receiverType = function.extensionReceiver?.resolve()?.toString()

        // Build parameter list
        val params = function.parameters.joinToString(", ") { param ->
            val name = param.name?.asString() ?: "_"
            val type = cleanTypeName(param.type.resolve().toString())
            val vararg = if (param.isVararg) "vararg " else ""
            "$vararg$name: $type"
        }

        // Get return type
        val returnType = function.returnType?.resolve()?.toString() ?: "Unit"

        // Build full signature
        return if (receiverType != null) {
            "$receiverType.$functionName($params): $returnType"
        } else {
            "$functionName($params): $returnType"
        }
    }

    /**
     * KSP renders type aliases as "[typealias Foo]" - strip that to just "Foo".
     */
    private fun cleanTypeName(type: String): String {
        return if (type.startsWith("[typealias ") && type.endsWith("]")) {
            type.removePrefix("[typealias ").removeSuffix("]")
        } else {
            type
        }
    }
}
