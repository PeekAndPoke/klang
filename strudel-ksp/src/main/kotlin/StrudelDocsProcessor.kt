package io.peekandpoke.klang.strudel.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.validate

/**
 * KSP processor that generates documentation entries from @StrudelDsl annotated functions.
 *
 * This processor:
 * 1. Finds all functions annotated with @StrudelDsl
 * 2. Extracts KDoc documentation from those functions
 * 3. Generates FunctionDoc entries automatically
 */
class StrudelDocsProcessor(
    environment: SymbolProcessorEnvironment,
) : SymbolProcessor {

    private val codeGenerator: CodeGenerator = environment.codeGenerator
    private val logger: KSPLogger = environment.logger

    override fun process(resolver: Resolver): List<KSAnnotated> {
        logger.info("StrudelDocsProcessor: Starting documentation generation")

        // Find all functions annotated with @StrudelDsl
        val strudelDslFunctions = resolver
            .getSymbolsWithAnnotation("io.peekandpoke.klang.strudel.lang.StrudelDsl")
            .filterIsInstance<KSFunctionDeclaration>()
            .toList()

        logger.info("StrudelDocsProcessor: Found ${strudelDslFunctions.size} @StrudelDsl functions")

        if (strudelDslFunctions.isEmpty()) {
            return emptyList()
        }

        // Generate documentation file
        generateDocsFile(strudelDslFunctions)

        // Return symbols that couldn't be processed (for incremental processing)
        return strudelDslFunctions.filterNot { it.validate() }
    }

    private fun generateDocsFile(functions: List<KSFunctionDeclaration>) {
        val file = codeGenerator.createNewFile(
            dependencies = Dependencies(aggregating = true),
            packageName = "io.peekandpoke.klang.strudel.lang.docs",
            fileName = "GeneratedStrudelDocs",
            extensionName = "kt"
        )

        file.bufferedWriter().use { writer ->
            writer.write(generateDocsCode(functions))
        }

        logger.info("StrudelDocsProcessor: Generated documentation file")
    }

    private fun generateDocsCode(functions: List<KSFunctionDeclaration>): String {
        // Group functions by name to handle overloads
        val functionsByName = functions.groupBy { it.simpleName.asString() }

        return buildString {
            appendLine("// Generated by StrudelDocsProcessor - DO NOT EDIT")
            appendLine()
            appendLine("package io.peekandpoke.klang.strudel.lang.docs")
            appendLine()
            appendLine("import io.peekandpoke.klang.script.docs.*")
            appendLine()
            appendLine("/**")
            appendLine(" * Auto-generated Strudel DSL function documentation.")
            appendLine(" * Generated from @StrudelDsl annotated functions.")
            appendLine(" * Platform-specific actual implementation of the expected declaration.")
            appendLine(" */")
            appendLine("actual val generatedStrudelFunctionDocs = mapOf(")

            functionsByName.entries.forEachIndexed { index, (name, overloads) ->
                append(generateFunctionDocEntry(name, overloads))
                if (index < functionsByName.size - 1) {
                    appendLine(",")
                }
            }

            appendLine()
            appendLine(")")
        }
    }

    private fun generateFunctionDocEntry(functionName: String, overloads: List<KSFunctionDeclaration>): String {
        logger.info("StrudelDocsProcessor: Processing function '$functionName' with ${overloads.size} overload(s)")

        // Parse KDoc for each overload
        val parsedKDocs = overloads.map { function ->
            val kdoc = function.docString
            if (kdoc != null) {
                logger.info("StrudelDocsProcessor: KDoc found for '$functionName'")
            } else {
                logger.warn("StrudelDocsProcessor: No KDoc found for '$functionName'")
            }
            KDocParser.parse(kdoc)
        }

        // Merge categories and tags from all overloads (prefer non-empty values)
        val category = parsedKDocs.mapNotNull { it.category }.firstOrNull() ?: "uncategorized"
        val allTags = parsedKDocs.flatMap { it.tags }.distinct()

        // Extract tags
        val tagsString = if (allTags.isNotEmpty()) {
            allTags.joinToString(", ") { "\"$it\"" }
        } else {
            ""
        }

        // Generate variants for all overloads
        val variants = overloads.zip(parsedKDocs).map { (function, kdoc) ->
            generateVariantDoc(function, kdoc)
        }

        return buildString {
            appendLine()
            appendLine("    \"$functionName\" to FunctionDoc(")
            appendLine("        name = \"$functionName\",")
            appendLine("        category = \"$category\",")
            appendLine("        tags = listOf($tagsString),")
            appendLine("        library = \"strudel\",")
            appendLine("        variants = listOf(")
            variants.forEachIndexed { index, variant ->
                append(variant)
                if (index < variants.size - 1) {
                    appendLine(",")
                }
            }
            appendLine()
            appendLine("        )")
            append("    )")
        }
    }

    private fun generateVariantDoc(function: KSFunctionDeclaration, kdoc: ParsedKDoc): String {
        // Determine variant type (TOP_LEVEL or EXTENSION_METHOD)
        val isExtension = function.extensionReceiver != null
        val variantType = if (isExtension) "DslType.EXTENSION_METHOD" else "DslType.TOP_LEVEL"

        // Build signature
        val signature = buildSignature(function)

        // Don't escape quotes in triple-quoted strings
        val description = kdoc.description.replace("\n", " ")

        // Generate parameter docs
        val paramDocs = function.parameters.mapNotNull { param ->
            val paramName = param.name?.asString() ?: return@mapNotNull null
            val paramType = param.type.resolve().toString()
            val paramDesc = kdoc.params[paramName] ?: ""

            val cleanDesc = paramDesc.replace("\n", " ")

            """
                ParamDoc(
                    name = "$paramName",
                    type = "$paramType",
                    description = "$cleanDesc"
                )
            """.trimIndent().prependIndent("                ")
        }

        val paramDocsString = if (paramDocs.isNotEmpty()) {
            paramDocs.joinToString(",\n")
        } else {
            ""
        }

        // Don't escape quotes in triple-quoted strings
        val returnDoc = kdoc.returnDoc.replace("\n", " ")

        // Generate sample strings - no escaping needed
        val samplesString = if (kdoc.samples.isNotEmpty()) {
            kdoc.samples.joinToString(",\n") { sample ->
                "                \"\"\"$sample\"\"\""
            }
        } else {
            ""
        }

        return buildString {
            appendLine("            VariantDoc(")
            appendLine("                type = $variantType,")
            appendLine("                signature = \"\"\"$signature\"\"\",")
            appendLine("                description = \"\"\"$description\"\"\",")
            if (paramDocs.isNotEmpty()) {
                appendLine("                params = listOf(")
                append(paramDocsString)
                appendLine()
                appendLine("                ),")
            } else {
                appendLine("                params = emptyList(),")
            }
            appendLine("                returnDoc = \"\"\"$returnDoc\"\"\",")
            if (kdoc.samples.isNotEmpty()) {
                appendLine("                samples = listOf(")
                append(samplesString)
                appendLine()
                appendLine("                )")
            } else {
                appendLine("                samples = emptyList()")
            }
            append("            )")
        }
    }

    private fun buildSignature(function: KSFunctionDeclaration): String {
        val functionName = function.simpleName.asString()

        // Get receiver type if it's an extension
        val receiverType = function.extensionReceiver?.resolve()?.toString()

        // Build parameter list
        val params = function.parameters.joinToString(", ") { param ->
            val name = param.name?.asString() ?: "_"
            val type = cleanTypeName(param.type.resolve().toString())
            val vararg = if (param.isVararg) "vararg " else ""
            "$vararg$name: $type"
        }

        // Get return type
        val returnType = function.returnType?.resolve()?.toString() ?: "Unit"

        // Build full signature
        return if (receiverType != null) {
            "$receiverType.$functionName($params): $returnType"
        } else {
            "$functionName($params): $returnType"
        }
    }

    /**
     * KSP renders type aliases as "[typealias Foo]" - strip that to just "Foo".
     */
    private fun cleanTypeName(type: String): String {
        return if (type.startsWith("[typealias ") && type.endsWith("]")) {
            type.removePrefix("[typealias ").removeSuffix("]")
        } else {
            type
        }
    }
}
