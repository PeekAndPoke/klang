package io.peekandpoke.klang.strudel.ksp

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate

/**
 * KSP processor that generates documentation entries from @StrudelDsl annotated functions and properties.
 *
 * This processor:
 * 1. Finds all functions and properties annotated with @StrudelDsl
 * 2. Extracts KDoc documentation from those symbols
 * 3. Generates FunctionDoc entries automatically
 */
class StrudelDocsProcessor(
    environment: SymbolProcessorEnvironment,
) : SymbolProcessor {

    private val codeGenerator: CodeGenerator = environment.codeGenerator
    private val logger: KSPLogger = environment.logger

    override fun process(resolver: Resolver): List<KSAnnotated> {
        logger.info("StrudelDocsProcessor: Starting documentation generation")

        val annotated = resolver.getSymbolsWithAnnotation("io.peekandpoke.klang.strudel.lang.StrudelDsl")

        val strudelDslFunctions = annotated.filterIsInstance<KSFunctionDeclaration>().toList()
        val strudelDslProperties = annotated.filterIsInstance<KSPropertyDeclaration>().toList()

        logger.info("StrudelDocsProcessor: Found ${strudelDslFunctions.size} @StrudelDsl functions")
        logger.info("StrudelDocsProcessor: Found ${strudelDslProperties.size} @StrudelDsl properties")

        if (strudelDslFunctions.isEmpty() && strudelDslProperties.isEmpty()) {
            return emptyList()
        }

        generateDocsFile(strudelDslFunctions, strudelDslProperties)

        val unprocessed = mutableListOf<KSAnnotated>()
        unprocessed.addAll(strudelDslFunctions.filterNot { it.validate() })
        unprocessed.addAll(strudelDslProperties.filterNot { it.validate() })
        return unprocessed
    }

    private fun generateDocsFile(
        functions: List<KSFunctionDeclaration>,
        properties: List<KSPropertyDeclaration>,
    ) {
        // Collect all source files that contain @StrudelDsl symbols so KSP's incremental
        // cache knows to regenerate this file whenever any of them changes.
        val sourceFiles = (functions.mapNotNull { it.containingFile } +
                properties.mapNotNull { it.containingFile }).distinct()

        val file = codeGenerator.createNewFile(
            dependencies = Dependencies(aggregating = true, *sourceFiles.toTypedArray()),
            packageName = "io.peekandpoke.klang.strudel.lang.docs",
            fileName = "GeneratedStrudelDocs",
            extensionName = "kt"
        )

        file.bufferedWriter().use { writer ->
            writer.write(generateDocsCode(functions, properties))
        }

        logger.info("StrudelDocsProcessor: Generated documentation file")
    }

    private fun generateDocsCode(
        functions: List<KSFunctionDeclaration>,
        properties: List<KSPropertyDeclaration>,
    ): String {
        // Group by name to handle overloads and property+function pairs
        val functionsByName = functions.groupBy { it.simpleName.asString() }
        val propertiesByName = properties.groupBy { it.simpleName.asString() }
        val allNames = (functionsByName.keys + propertiesByName.keys).distinct().sorted()

        // Split into chunks to avoid JVM MethodTooLargeException (64 KB limit per method).
        // Each chunk becomes a separate private function so no single <clinit> or function
        // exceeds the JVM bytecode size limit.
        val chunks = allNames.chunked(8)

        return buildString {
            appendLine("// Generated by StrudelDocsProcessor - DO NOT EDIT")
            appendLine()
            appendLine("package io.peekandpoke.klang.strudel.lang.docs")
            appendLine()
            appendLine("import io.peekandpoke.klang.script.docs.*")
            appendLine()
            appendLine("/**")
            appendLine(" * Auto-generated Strudel DSL function documentation.")
            appendLine(" * Generated from @StrudelDsl annotated functions and properties.")
            appendLine(" * Platform-specific actual implementation of the expected declaration.")
            appendLine(" */")

            // One private function per chunk — each stays well within the 64 KB method limit.
            chunks.forEachIndexed { chunkIdx, chunk ->
                appendLine("private fun generatedDocsChunk$chunkIdx() = mapOf(")
                chunk.forEachIndexed { entryIdx, name ->
                    val overloads = functionsByName[name] ?: emptyList()
                    val props = propertiesByName[name] ?: emptyList()
                    append(generateDocEntry(name, overloads, props))
                    if (entryIdx < chunk.size - 1) {
                        appendLine(",")
                    }
                }
                appendLine()
                appendLine(")")
                appendLine()
            }

            // The actual val just combines all chunk maps — keeps <clinit> tiny.
            appendLine("actual val generatedStrudelFunctionDocs: Map<String, FunctionDoc> = buildMap {")
            chunks.forEachIndexed { chunkIdx, _ ->
                appendLine("    putAll(generatedDocsChunk$chunkIdx())")
            }
            appendLine("}")
        }
    }

    private fun generateDocEntry(
        functionName: String,
        overloads: List<KSFunctionDeclaration>,
        properties: List<KSPropertyDeclaration>,
    ): String {
        logger.info(
            "StrudelDocsProcessor: Processing '$functionName' — " +
                    "${overloads.size} function(s), ${properties.size} property(-ies)"
        )

        val parsedFunctionKDocs = overloads.map { function ->
            val kdoc = function.docString
            if (kdoc != null) {
                logger.info("StrudelDocsProcessor: KDoc found for function '$functionName'")
            } else {
                logger.warn("StrudelDocsProcessor: No KDoc found for function '$functionName'")
            }
            KDocParser.parse(kdoc)
        }

        val parsedPropertyKDocs = properties.map { property ->
            val kdoc = property.docString
            if (kdoc == null) {
                logger.warn("StrudelDocsProcessor: No KDoc found for property '$functionName'")
            }
            KDocParser.parse(kdoc)
        }

        val allParsedKDocs = parsedFunctionKDocs + parsedPropertyKDocs

        // Merge category, tags and aliases from all overloads and properties (prefer non-empty)
        val category = allParsedKDocs.mapNotNull { it.category }.firstOrNull() ?: "uncategorized"
        val allTags = allParsedKDocs.flatMap { it.tags }.distinct()
        val allAliases = allParsedKDocs.flatMap { it.aliases }.distinct()

        val tagsString = if (allTags.isNotEmpty()) {
            allTags.joinToString(", ") { "\"$it\"" }
        } else {
            ""
        }

        val aliasesString = if (allAliases.isNotEmpty()) {
            allAliases.joinToString(", ") { "\"$it\"" }
        } else {
            ""
        }

        // Functions first, then properties (properties are the raw/unscaled form)
        val variants = buildList {
            overloads.zip(parsedFunctionKDocs).forEach { (fn, kdoc) ->
                add(generateVariantDoc(fn, kdoc))
            }
            properties.zip(parsedPropertyKDocs).forEach { (prop, kdoc) ->
                add(generatePropertyVariantDoc(prop, kdoc))
            }
        }

        return buildString {
            appendLine()
            appendLine("    \"$functionName\" to FunctionDoc(")
            appendLine("        name = \"$functionName\",")
            appendLine("        category = \"$category\",")
            appendLine("        tags = listOf($tagsString),")
            appendLine("        aliases = listOf($aliasesString),")
            appendLine("        library = \"strudel\",")
            appendLine("        variants = listOf(")
            variants.forEachIndexed { index, variant ->
                append(variant)
                if (index < variants.size - 1) {
                    appendLine(",")
                }
            }
            appendLine()
            appendLine("        )")
            append("    )")
        }
    }

    private fun generateVariantDoc(function: KSFunctionDeclaration, kdoc: ParsedKDoc): String {
        val isExtension = function.extensionReceiver != null
        val variantType = if (isExtension) "DslType.EXTENSION_METHOD" else "DslType.TOP_LEVEL"

        val description = kdoc.description.replace("\n", " ")
        val returnDoc = kdoc.returnDoc.replace("\n", " ")

        val samplesString = if (kdoc.samples.isNotEmpty()) {
            kdoc.samples.joinToString(",\n") { sample ->
                "                \"\"\"$sample\"\"\""
            }
        } else {
            ""
        }

        return buildString {
            appendLine("            VariantDoc(")
            appendLine("                type = $variantType,")
            append("                signatureModel = ")
            append(generateFunctionSignatureModelCode(function, kdoc))
            appendLine(",")
            appendLine("                description = \"\"\"$description\"\"\",")
            appendLine("                returnDoc = \"\"\"$returnDoc\"\"\",")

            if (kdoc.samples.isNotEmpty()) {
                appendLine("                samples = listOf(")
                append(samplesString)
                appendLine()
                appendLine("                )")
            } else {
                appendLine("                samples = emptyList()")
            }
            append("            )")
        }
    }

    /**
     * Generates `SignatureModel(...)` code for a function declaration.
     * The returned string starts with `SignatureModel(` and ends with `                )` (16-space indent).
     */
    private fun generateFunctionSignatureModelCode(function: KSFunctionDeclaration, kdoc: ParsedKDoc): String {
        val functionName = function.simpleName.asString()
        val receiverType = function.extensionReceiver?.resolve()
        val returnType = function.returnType?.resolve()

        return buildString {
            appendLine("SignatureModel(")
            appendLine("                    name = \"$functionName\",")
            if (receiverType != null) {
                appendLine("                    receiver = ${generateTypeModelCode(receiverType)},")
            }
            val params = function.parameters
            if (params.isNotEmpty()) {
                appendLine("                    params = listOf(")
                params.forEach { param ->
                    val paramName = param.name?.asString() ?: return@forEach
                    val paramType = param.type.resolve()
                    val paramDesc = (kdoc.params[paramName] ?: "").replace("\n", " ")
                    append("                        ParamModel(")
                    append("name = \"$paramName\", ")
                    append("type = ${generateTypeModelCode(paramType)}")
                    if (param.isVararg) append(", isVararg = true")
                    if (paramDesc.isNotEmpty()) append(", description = \"\"\"$paramDesc\"\"\"")
                    appendLine("),")
                }
                appendLine("                    ),")
            } else {
                appendLine("                    params = emptyList(),")
            }
            if (returnType != null) {
                appendLine("                    returnType = ${generateTypeModelCode(returnType)},")
            }
            append("                )")
        }
    }

    /** Generates `TypeModel(...)` code for a resolved KSP type. */
    private fun generateTypeModelCode(type: KSType): String {
        val declaration = type.declaration
        val simpleName = declaration.simpleName.asString()
        val isTypeAlias = declaration is KSTypeAlias
        val isNullable = type.nullability == Nullability.NULLABLE

        return buildString {
            append("TypeModel(simpleName = \"$simpleName\"")
            if (isTypeAlias) append(", isTypeAlias = true")
            if (isNullable) append(", isNullable = true")
            append(")")
        }
    }

    private fun generatePropertyVariantDoc(property: KSPropertyDeclaration, kdoc: ParsedKDoc): String {
        val propertyName = property.simpleName.asString()
        val propertyType = property.type.resolve()
        val propertyTypeSimpleName = propertyType.declaration.simpleName.asString()
        val isExtension = property.extensionReceiver != null

        // DslFunction / DslPatternMethod are callable delegates — not plain objects
        val isDslCallable = propertyTypeSimpleName in setOf("DslFunction", "DslPatternMethod")
        val variantType = when {
            isExtension -> "DslType.EXTENSION_METHOD"
            isDslCallable -> "DslType.TOP_LEVEL"
            else -> "DslType.OBJECT"
        }

        val signatureModelCode = buildPropertySignatureModelCode(
            propertyName = propertyName,
            propertyType = propertyType,
            isDslCallable = isDslCallable,
            receiverType = if (isExtension) property.extensionReceiver!!.resolve() else null,
        )

        val description = kdoc.description.replace("\n", " ")

        val samplesString = if (kdoc.samples.isNotEmpty()) {
            kdoc.samples.joinToString(",\n") { sample ->
                "                \"\"\"$sample\"\"\""
            }
        } else {
            ""
        }

        return buildString {
            appendLine("            VariantDoc(")
            appendLine("                type = $variantType,")
            append("                signatureModel = ")
            append(signatureModelCode)
            appendLine(",")
            appendLine("                description = \"\"\"$description\"\"\",")
            appendLine("                returnDoc = \"\",")
            if (kdoc.samples.isNotEmpty()) {
                appendLine("                samples = listOf(")
                append(samplesString)
                appendLine()
                appendLine("                )")
            } else {
                appendLine("                samples = emptyList()")
            }
            append("            )")
        }
    }

    /**
     * Generates `SignatureModel(...)` code for a property declaration.
     * The returned string starts with `SignatureModel(` and ends with `                )` (16-space indent).
     */
    private fun buildPropertySignatureModelCode(
        propertyName: String,
        propertyType: KSType,
        isDslCallable: Boolean,
        receiverType: KSType?,
    ): String = buildString {
        appendLine("SignatureModel(")
        appendLine("                    name = \"$propertyName\",")
        if (receiverType != null) {
            appendLine("                    receiver = ${generateTypeModelCode(receiverType)},")
        }
        if (isDslCallable) {
            // Callable delegate — show empty param list (we don't know the actual params from the property)
            appendLine("                    params = emptyList(),")
            appendLine("                    returnType = TypeModel(simpleName = \"StrudelPattern\"),")
        } else {
            // Plain object / constant — no parens in signature (params = null by default)
            appendLine("                    returnType = ${generateTypeModelCode(propertyType)},")
        }
        append("                )")
    }
}
