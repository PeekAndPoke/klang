package io.peekandpoke.klang.strudel.math

import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlin.jvm.JvmInline
import kotlin.math.roundToLong

/**
 * Rational number representation using 32.32 Fixed Point arithmetic.
 *
 * This implementation is a `value class`, meaning it is inlined to a primitive [Long] at runtime,
 * resulting in zero heap allocations for arithmetic operations.
 *
 * It uses 32 bits for the fractional part, providing a resolution of ~2.3e-10.
 */
@Serializable(with = RationalSerializer::class)
@JvmInline
value class Rational private constructor(private val bits: Long) : Comparable<Rational> {

    companion object {
        private const val PRECISION_BITS = 32
        private const val MULTIPLIER_D = 4294967296.0 // 2^32 as Double
        private const val MULTIPLIER_L = 1L shl PRECISION_BITS
        private const val FRACTION_MASK = MULTIPLIER_L - 1

        /** Zero as a rational number */
        val ZERO = Rational(0L)

        /** Half as rational number */
        val HALF = Rational(0.5)

        /** One as a rational number */
        val ONE = Rational(MULTIPLIER_L)

        /** Two as a rational number */
        val TWO = Rational(2)

        /** Negative one as a rational number */
        val MINUS_ONE = Rational(-MULTIPLIER_L)

        /** NaN as a rational number, represented by the minimum Long value */
        val NaN = Rational(Long.MIN_VALUE)

        /** Creates a Rational from a [Long] */
        operator fun invoke(value: Long): Rational = Rational(value shl PRECISION_BITS)

        /** Creates a Rational from an [Int] */
        operator fun invoke(value: Int): Rational = invoke(value.toLong())

        /** Creates a Rational from a [Double] by rounding to the nearest fixed-point step */
        operator fun invoke(value: Double): Rational {
            if (value.isNaN() || value.isInfinite()) return NaN
            return Rational((value * MULTIPLIER_D).roundToLong())
        }

        /** Extension to convert any [Number] to a Rational */
        fun Number.toRational(): Rational = invoke(this.toDouble())

        fun List<Rational>.sum(): Rational = fold(ZERO) { acc, r -> acc + r }
    }

    /** Returns true if this value represents NaN */
    val isNaN: Boolean get() = bits == NaN.bits

    // --- Arithmetic Operators ---

    /** Adds two rational numbers */
    operator fun plus(other: Rational): Rational =
        if (isNaN || other.isNaN) NaN else Rational(bits + other.bits)

    /** Subtracts another rational number from this one */
    operator fun minus(other: Rational): Rational =
        if (isNaN || other.isNaN) NaN else Rational(bits - other.bits)

    /**
     * Multiplies two rational numbers.
     * Uses Double for the intermediate product to prevent 64-bit overflow.
     */
    operator fun times(other: Rational): Rational {
        if (isNaN || other.isNaN) return NaN
        val res = (bits.toDouble() * other.bits.toDouble()) / MULTIPLIER_D
        return Rational(res.toLong())
    }

    /**
     * Divides this rational by another.
     * Uses Double for the intermediate to prevent 64-bit overflow.
     */
    operator fun div(other: Rational): Rational {
        if (isNaN || other.isNaN || other.bits == 0L) return NaN
        val res = (bits.toDouble() / other.bits.toDouble()) * MULTIPLIER_D
        return Rational(res.toLong())
    }

    /** Computes the remainder of division between two rational numbers */
    operator fun rem(other: Rational): Rational {
        if (isNaN || other.isNaN || other.bits == 0L) return NaN
        return Rational(bits % other.bits)
    }

    /** Negates the rational number */
    operator fun unaryMinus(): Rational = if (isNaN) NaN else Rational(-bits)

    // --- Number Interoperability ---

    operator fun plus(other: Number): Rational = this + other.toRational()
    operator fun minus(other: Number): Rational = this - other.toRational()
    operator fun times(other: Number): Rational = this * other.toRational()
    operator fun div(other: Number): Rational = this / other.toRational()
    operator fun rem(other: Number): Rational = this % other.toRational()

    // --- Comparison ---

    override operator fun compareTo(other: Rational): Int {
        if (isNaN && other.isNaN) return 0
        if (isNaN) return 1
        if (other.isNaN) return -1

        return bits.compareTo(other.bits)
    }

    // --- Conversions ---

    /** Converts the fixed-point value back to a [Double] */
    fun toDouble(): Double = if (isNaN) Double.NaN else bits.toDouble() / MULTIPLIER_D

    /** Converts to [Long], truncating the fractional part */
    fun toLong(): Long = if (isNaN) 0L else bits shr PRECISION_BITS

    /** Converts to [Int], truncating the fractional part */
    fun toInt(): Int = toLong().toInt()

    // --- Utilities ---

    /** Returns the absolute value of this rational */
    fun abs(): Rational {
        if (isNaN) return NaN
        return if (bits < 0) Rational(-bits) else this
    }

    /** Returns the largest integer (as Rational) less than or equal to this value */
    fun floor(): Rational {
        if (isNaN) return NaN
        return Rational((bits shr PRECISION_BITS) shl PRECISION_BITS)
    }

    /** Returns the smallest integer (as Rational) greater than or equal to this value */
    fun ceil(): Rational {
        if (isNaN) return NaN
        val f = floor()
        return if (f.bits == bits) f else Rational(f.bits + MULTIPLIER_L)
    }

    /** Returns the fractional part of the number (the remainder after floor) */
    fun frac(): Rational {
        if (isNaN) return NaN
        return Rational(bits and FRACTION_MASK)
    }

    /**
     * Rounds to the nearest integer (as Rational).
     * Uses "round half away from zero" rule:
     * - 2.5 rounds to 3
     * - -2.5 rounds to -3
     * - 2.4 rounds to 2
     * - -2.6 rounds to -3
     */
    fun round(): Rational {
        if (isNaN) return NaN

        val half = Rational(MULTIPLIER_L shr 1) // 0.5 in fixed-point

        // For positive numbers: floor(x + 0.5)
        // For negative numbers: ceil(x - 0.5)
        return if (bits >= 0) {
            (this + half).floor()
        } else {
            (this - half).ceil()
        }
    }

    /**
     * Computes Euler's number `e` raised to the power of this value.
     *
     * Special cases:
     *   - `exp(NaN)` is `NaN`
     *   - `exp(+Inf)` would be `+Inf` (represented as NaN in fixed-point)
     *   - `exp(-Inf)` would be `0.0`
     *   - Very large positive values may result in NaN due to overflow
     *   - Very large negative values approach 0
     *
     * Note: This function uses Double precision internally, so results are
     * limited by Double precision (~15-17 significant decimal digits).
     */
    fun exp(): Rational {
        if (isNaN) return NaN

        val result = kotlin.math.exp(toDouble())

        // Check for infinity or NaN from the exp calculation
        if (result.isNaN() || result.isInfinite()) {
            return NaN
        }

        return Rational(result)
    }

    override fun toString(): String = if (isNaN) "NaN" else toDouble().toString()
}

object RationalSerializer : KSerializer<Rational> {
    override val descriptor: SerialDescriptor =
        PrimitiveSerialDescriptor("Rational", PrimitiveKind.DOUBLE)

    override fun serialize(encoder: Encoder, value: Rational) {
        encoder.encodeDouble(value.toDouble())
    }

    override fun deserialize(decoder: Decoder): Rational {
        return Rational(decoder.decodeDouble())
    }
}

/**
 * Serializer that converts Rational to/from string format like "2/3" or "-5/8"
 */
object RationalStringSerializer : KSerializer<Rational> {
    override val descriptor: SerialDescriptor =
        PrimitiveSerialDescriptor("RationalString", PrimitiveKind.STRING)

    override fun serialize(encoder: Encoder, value: Rational) {
        if (value.isNaN) {
            encoder.encodeString("NaN")
            return
        }

        val str = toFractionString(value.toDouble())
        encoder.encodeString(str)
    }

    override fun deserialize(decoder: Decoder): Rational {
        val str = decoder.decodeString().trim()

        if (str == "NaN") {
            return Rational.NaN
        }

        // Handle fraction format "numerator/denominator"
        if ("/" in str) {
            val parts = str.split("/")
            if (parts.size == 2) {
                val num = parts[0].trim().toDoubleOrNull()
                val den = parts[1].trim().toDoubleOrNull()

                // Check for valid numerator and denominator
                if (num != null && den != null) {
                    // Division by zero results in NaN
                    if (den == 0.0) {
                        return Rational.NaN
                    }
                    return Rational(num / den)
                }
            }
            // Malformed fraction (wrong number of parts, or non-numeric values)
            return Rational.NaN
        }

        // Fallback: try parsing as plain number
        val d = str.toDoubleOrNull()
        return if (d != null) {
            Rational(d)
        } else {
            Rational.NaN
        }
    }

    /**
     * Converts a double to a fraction string using the continued fraction algorithm.
     * Handles positive and negative values, producing strings like "2/3" or "-5/8".
     */
    private fun toFractionString(d: Double): String {
        if (d.isNaN()) return "NaN"
        if (d.isInfinite()) return if (d > 0) "Infinity" else "-Infinity"
        if (d == 0.0) return "0/1"

        // Handle sign
        val negative = d < 0
        val sign = if (negative) "-" else ""
        val absD = kotlin.math.abs(d)

        // Use continued fraction algorithm for accurate conversion
        val (num, den) = doubleToFraction(absD)

        return "$sign$num/$den"
    }

    /**
     * Converts a positive double to numerator/denominator pair using continued fractions.
     * This provides the most accurate rational approximation within the denominator limit.
     */
    private fun doubleToFraction(d: Double, maxDenominator: Long = 1_000_000L): Pair<Long, Long> {
        if (d == 0.0) return Pair(0L, 1L)

        // Check if it's already an integer
        val asLong = d.toLong()
        if (kotlin.math.abs(d - asLong.toDouble()) < 1e-10) {
            return Pair(asLong, 1L)
        }

        val tolerance = 1e-10
        var h1 = 1L  // numerator
        var h2 = 0L
        var k1 = 0L  // denominator
        var k2 = 1L
        var b = d

        // Continued fraction algorithm
        var iterations = 0
        while (iterations < 100) {
            val a = b.toLong()
            val aux1 = h1
            h1 = a * h1 + h2
            h2 = aux1

            val aux2 = k1
            k1 = a * k1 + k2
            k2 = aux2

            // Check if we've reached our precision goal or denominator limit
            if (k1 >= maxDenominator) {
                // Use previous convergent
                return Pair(h2, k2)
            }

            val approximation = h1.toDouble() / k1.toDouble()
            if (kotlin.math.abs(d - approximation) < tolerance) {
                break
            }

            b = 1.0 / (b - a)
            if (b.isInfinite() || b.isNaN()) {
                break
            }

            iterations++
        }

        // Simplify by GCD
        val gcd = gcd(h1, k1)
        return Pair(h1 / gcd, k1 / gcd)
    }

    private fun gcd(a: Long, b: Long): Long {
        var x = kotlin.math.abs(a)
        var y = kotlin.math.abs(b)
        while (y != 0L) {
            val temp = y
            y = x % y
            x = temp
        }
        return x
    }
}
